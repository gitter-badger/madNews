// Что прочитать чтоб этот файл лучше понять:
// http://habrahabr.ru/company/SECL_GROUP/blog/204510/
// http://habrahabr.ru/post/38730/



// После того как прочтете статьи по ссылкам приступайте к дальнейшему чтению этого файла.
// Итак=) 
// Для простоты я буду использовать следующие сокращения:
// >>> GET /users/
// , где  '>>>' означает отправку НА сервер. Соответственно '<<<' будет означать 
// ответ сервера клиенту.
// GET - http метод (возможные варианты: POST, PUT, DELETE).
// /users/  - url по которому обращаемся к серверу.
// Теперь пример. Запросим список фруктов у сервера и получим в ответ список 
// типа [яблоко, банан, клубника]

>>> GET /fruits/
<<< [
	{"id":1, "name":"apple"},
	{"id":2, "name":"banana"},
	{"id":3, "name":"strawberrie"}
]

// Также для запросов типа POST, PUT будут дополнительные параметры (они НЕ включаются 
// в url, а отправляются В запросе).
// Пример. Создадим новый фрукт с именем "апельсин". В ответ сервер должен вернуть 
// только что созданный объект либо ошибку.

>>> POST /fruits/ 		{"name":"orange"}
<<< {"id":4, "name":"orange"}
// вернем ошибку в Json
<<< {"error":"Can't create"}
// либо вернем ошибку http (например, 404). 
<<< HTTP 404

// теперь проверим список всех фруктов с сервера (пусть 1 запрос с POST прошел успешно).

>>> GET /fruits/
<<< [
	{"id":1, "name":"apple"},
	{"id":2, "name":"banana"},
	{"id":3, "name":"strawberrie"},
	{"id":4, "name":"orange"},
]

// Чтоб каждый раз не писать в ответе сервера {"id":1, "name":"apple"} я буду называть 
// это объектом FRUIT. т.е. FRUIT={"id":x, "name":x}, где х - какое-то значение.
// В начале каждого раздела я дам аннотацию такого типа для объекта:

FRUIT={
	"id": int,		//2
	"name": String,		//"orange"
*	"taste":String,		//"yamee"
}

// Думаю, понятно, что я показываю ИМЯ поля, ТИП поля и в комментарии даю ПРИМЕР
// возможного значения. * - значит что поле не обязательное (у некоторых объектов
// может быть, а у некоторых нет).


// Ну чтож, теперь приступим к самому интересному=)
// По логике вещей мы должны разделить публичное аpi к которому могут обращаться все
// и приватное (к которому возможно обращение только по токену).
// Почему по токену? Rest сервер не должен хранить у себя следы логина пользователя.
// Вот такой ответ=) Конечно, если нам сложно будет привинтить авторизацию по логину/паролю
// с дальнейшим использованием токена, то придется использовать авторизацию 
// на сервере (что не есть хорошо).


// ПРИМЕЧАНИЕ: если вам будет сложно использовать timestamp для даты и времени,
// я допускаю возможность отдачи даты и времени от сервера в формате:
// {"some-field":12, "date":"10-20-1990", "time":"01:04:33"}


// ==================================ПУБЛИЧНОЕ API===================================
// Имеет смысл использовать префикс /api/v1/public/ для таких url.
// Помните: публичное api не имеет http методов POST, PUT, DELETE! С помощью него
// можно только просматривать - GET.
// ==================================================================================
// ОБЪЕКТ "Сокращенная Новость". Будет использован на главной странице для отображения 
// в списке всех новостей.

NEWS_SHORT={
		"id": int,			//4
		"title":String			//"Сегодня убили кота."
		"short_text":String,		//"Неожидано утром этого дня бла-бла....."
		"timestamp":int,		//1920129931
*		"main_img":String,		//"/media_files/news/img/kot.png"
*		"position":int,			//2	
*		"featured":boolean,		//true
		"show_on_main":boolean		//true
}
// timestamp - время добавления. Это время в формате unixtime 
// http://en.wikipedia.org/wiki/Unix_time
// никаких "10:22" и "25 Апр 1990" т.к. unixtime очень гибок для рендеринга потом 
// даты и времени в любом формате.
// position - № в списке всех новостей.
// featured - является ли новость "зафичеренной".
// show_on_main - показывать ли новость на главной. По идее все запросы к публичному 
// api должны возвращать только новости с полем show_on_main=true.
// =================================================================================
// ОБЪЕКТ "Тег"

TAG={
	"id":int,		//43
	"name":String,		//"Бульён из единорога"
	"popularity":int,	//372
}

// popularity - насколько часто данный тег используется. Это значение потом будет 
// использовано в облаке тегов для указания размера шрифта и цвета тега.
// =================================================================================
// ОБЪЕКТ "Полная Новость". Будет использован собственно на странице с самой новостью и
// комментариями.

NEWS={
	"id": int,			//4
	"title":String			//"Сегодня убили кота."
	"timestamp":int,		//1920129931
	"html":String,			//"<p>Неожидано утром этого дня...</p>..."
	"tags":[TAG, TAG ... TAG, TAG]	//
}

// html - текст со всей разметкой которую мы получим через ckeditor.
// tags - просто список объектов тегов в [].
// ==================================================================================
// ==================================================================================
// Теперь ЗАПРОСЫ к ПУБЛИЧНОМУ API

// 1. Главная новость дня.

>>> GET /api/v1/public/news/top/
<<< NEWS

// 2. Список обычных новостей для главной страницы.

>>> GET /api/v1/public/news/
<<< [NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]

// 3. Получение списка новостей из архива за определенный день:
// прим.: поскольку malgin не хочет на странице календарь, а хочет сквозной список, 
// то нужно будет использовать сдвиг для получения объектов

>>> GET /api/v1/public/archive/?limit=(<N1>)&offset=(<N2>)
<<< {
	"count": (<N3>),
	"result":[NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]
}

// где (<N1>) - количество объектов которые нужно получить из бд за 1 раз.
// (<N2>) - сдвиг от начала всей коллекции объектов.
// (<N3>) - сервер обязательно в ответе должен сказать сколько всего
// объектов в бд. Примеры. Получим первые 20 новостей из архива:

>>> GET /api/v1/public/archive/?limit=20
<<< {
	"count": 1023,
	"result":[NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]
}

// Получим 40 новостей из ахрива со сдвигом в 30 объектов:

>>> GET /api/v1/public/archive/?limit=40&offset=30
<<< {
	"count": 1023,
	"result":[NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]
}

// 4. Получение всей инфы об одной новости.

>>> GET /api/v1/public/news/1/
<<< NEWS

// небольшое пояснение. 1 - это id новости. т.е чтоб запросить с сервера новость
// c id=103 нужно стучаться на такой url:

>>> GET /api/v1/public/news/103/
<<< NEWS

// 5. Получение всех тегов. 

>>> GET /api/v1/public/tags/
<<< [TAG, TAG ... TAG, TAG]

// 6. Получение всех связанных новостей с тегом.

>>> GET /api/v1/public/news/?tag=1
<<< {
	"count": 123,
	"result":[NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]
}

// 1 - id тега.
// и "пагинация":

>>> GET /api/v1/public/news/?tag=1&limit=20&offset=100
<<< {
	"count": 123,
	"result":[NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]
}

// 7. Поиск новости по строке

>>> GET /api/v1/public/news/?search="Bla-bla-bla"
<<< {
	"count": 423,
	"result":[NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]
}

// при запросе, если объектов больше чем 100(например) сервер должен их бить 
// на части. Например, с моей стороны я запрошу 50 новостей со сдвигом в 100:

>>> GET /api/v1/public/news/?search="Bla-bla-bla"&limit=50&offset=100
<<< {
	"count": 423,
	"result":[NEWS_SHORT, NEWS_SHORT ... NEWS_SHORT,NEWS_SHORT]
}

// ==================================ПРИВАТНОЕ API===================================
// Имеет смысл использовать префикс /api/v1/private/ для таких url.
// Тут будут работать такие методы http:
//   GET - получение объекта.
//   POST - создание нового объекта.
//   PUT - редактирование объекта.
//   DELETE - удаление объекта.
// ==================================================================================
// Объект "Пользователь":

USER={
	"id":int,				//22
	"username":String,			//"Andrey"
	"email":String,				//"hello@kitty.org"
**	"permissions":[String, String ...]	//["news-edit-any", "news-add-edit-delete-own"]
**	"role": String,				//"writer"
}

// ** - эти поля я оставляю на выбор. что будет легче реализовать то я и буду 
// использовать на своей стороне.
// permission - поля разрешения пользователя на доступ к приватному api. Все возможные поля
// отображены в макете админки.
// role - роль пользователя (за комментариями к Андрею=) ).

// ==================================================================================
// ==================================================================================
// ЗАПРОСЫ к ПРИВАТНОМУ API

// 1. Админ прежде чем добавить пользователя должен проверить нет ли мыла этого
// нового пользователя в бд:

>>> GET /api/v1/private/helpers/email-not-in-db/(<email>)
<<< {
	"email": (<email>),
	"in_db": (<in_db>),
}

// где (<email>) - мыло пользователя которое нужно проверить.
// (<in_db>) - boolean - результат проверки. Например, проверим мыло, которое уже
// есть в бд:

>>> GET /api/v1/private/helpers/email-not-in-db/hello@kitty.org
<<< {
	"email": "hello@kitty.org",
	"in_db": true,
}

// 2. Также нужно проверить и username создаваемого пользователя:

>>> GET /api/v1/private/helpers/username-not-in-db/(<username>)
<<< {
	"username": (<username>),
	"in_db": (<in_db>),
}

// 3. Создание админом нового пользователя:

>>> POST /api/v1/private/users/		{"email":(<email>), "username":(<username>)}
<<< USER

// после этого запроса сервер должен отправить письмо пользователю с его юзернеймом.
// Также malgin говорил, что пользователь должен будет установить себе пароль,
// но может сократим работу на сервере и на клиенте? Может пусть лучше 
// сервер отправляет сгенеренный пароль на почту? FIXME:это нужно обсудить.

// 4. Редактирование свойств пользователя админом:

>>> PUT /api/v1/private/users/(<id>)		{"permissions":(<permissions>), ...}
<<< USER

// где - (<id>) - id пользователя в бд. В запросе указываются все поля которые нужно изменить.
// Пароль через эту форму нельзя менять!

// 5. Удаление пользователя админом:

>>> DELETE /api/v1/private/users/(<id>)	
<<< {}

// в ответ сервер должен прислать либо пустой Json либо ошибку. Например, обычный пользователь пытается 
// удалить другого пользователя:

>>> DELETE /api/v1/private/users/22	
<<< {'error':["You'r not admin"]}

// 6. Установка нового пароля:

>>> PUT /api/v1/private/users/(<id>)/password/(<newPassword>)/(<oldPassword>)
<<< USER

// пароль может менять либо сам пользователь, либо админ. Для админа поле oldPassword 
// должно игнорироваться. Для обычного пользователя пытающегося изменить чужой пароль должна
// выскакивать ошибка.

// 7. Создание новой новости:

>>> POST /api/v1/private/news/		NEWS*
<<< NEWS*

// NEWS* который постится на сервер не будет содержать в себе полей id и timestamp.
// NEWS* - в нем все поля из NEWS и NEWS_SHORT.
// Опять таки, пользователь не имеющий прав создавать новость должен получить ошибку.

// 8. Редактирование новости:

>>> PUT /api/v1/private/news/(<id>)		NEWS*
<<< NEWS*

// NEWS* который будет отправляться на сервер не будет содержать в себе полей id и timestamp.
// Должен вернуть ошибку для тех, кто не может редактировать новость.
// Если не редактор (и не админ) попытаются поменять поля featured и postition для них
// тоже должна вернуться ошибка.

// 9. Получение списка всех новостей за день:

>>> GET /api/v1/private/news/
<<< [NEWS*, NEWS*, ... NEWS*]

// отличия этого метода от его близнеца в публичном api в том, что у объекта NEWS*
// будут все необходимые поля и возвращаться также будут и те новости, 
// у которых show_on_main == false.
// Для каждого пользователя нужно возвращать свою коллекцию. Для админа/редактора/корректора - 
// все новости, для писателя - только собственные записи.
// =========================================================================================
// Кажется это все=) Если что-то забыл, то пишите в чат. Принимаю изменения в формате diff. 


